---
minread: 8
draft: false
comments: true
title: "API Design in C++ Libraries"
description: "C++ is a powerful language, but it's also incredibly easy to shoot yourself in the foot with it"
date: 2025-11-30T08:21:27-08:00
---

I was programming an arbitrary precision integer library in C++ (more on this in a [later blog](/blog/05)) when I ran into a couple of issues regarding API design. For context, the library itself is header-only since I wanted to simplify the installation as much as possible. It's also small because I am writing it for fun to learn about arbitrary precision arithmetic in computers and API design in general. 

In my library, I exposed a big integer class (which we'll call here `BigInt`), which stores an `std::vector` of 32-bit integers resized based on the value the object represents. For example, if the dynamic array has 3 elements, then it can hold a maximum of 96-bit number. The internal representations and implementations are not important for the blog. 

For any arbitrary precision arithmetic library to be useful, there obviously has to be [algorithms to do the arithmetic](https://gmplib.org/manual/Algorithms). The functions that implement the algorithms are generally **not** class members, since that would bloat the size of the class too much. In addition, if one is overloading the operators for `BigInt`, they might also want to [place it outside](https://stackoverflow.com/q/2425906/23241571) the class. 

My goal was to have a set of functions that are a part of the internal functions and not members of the class that implements the algorithms. Other functions that are a part of the public API would use the functions that implement the algorithms. Therefore, I wrote the following code:

```cpp
namespace mylib {

class BigInt {
public:
    ...
private:
    ...
};

BigInt public_func_1(const BigInt& value);
BigInt public_func_2(const BigInt& value);

namespace internal {

BigInt internal_algo_1(const BigInt& value);
BigInt internal_algo_2(const BigInt& value);
BigInt internal_algo_3(const BigInt& value);
BigInt internal_algo_4(const BigInt& value);

} // namespace internal
} // namespace mylib
```

In order for the various algorithms to do their job, they will need access to the private member variables in `BigInt`. One way to give access is by implementing getters for the members. However, since I didn't want to also expose `BigInt`'s private members for reading and writing by users of the library, I did not want to define publically accessible getters. As such, I tried look for a different way to accomplish the same thing. 

## Other Solutions

Another possibility that C++ provides to give our algorithms access to `BigInt`'s private members is by declaring these functions as [friends of the class](https://www.en.cppreference.com/w/cpp/language/friend.html). Since this only gives internal functions access to `BigInt`'s privates and doesn't give users access, I opted to go this route. 


```cpp
namespace mylib {

// Forward declares
class BigInt;

namespace internal {

BigInt internal_algo_1(const BigInt& value);
BigInt internal_algo_2(const BigInt& value);
BigInt internal_algo_3(const BigInt& value);
BigInt internal_algo_4(const BigInt& value);

} // namespace internal

class BigInt {
public:
    friend BigInt internal::internal_algo_1(const BigInt& value);
    friend BigInt internal::internal_algo_2(const BigInt& value);
    friend BigInt internal::internal_algo_3(const BigInt& value);
    friend BigInt internal::internal_algo_4(const BigInt& value);
    ...
private:
    ...
};

BigInt public_func_1(const BigInt& value);
BigInt public_func_2(const BigInt& value);

} // namespace mylib
```

As demonstrated above, there are quite a bit of forward declaration needed. This makes the coupling between the internal algorithms and the class tighter, which is not ideal. After tweaking the files for a bit, I scrapped this idea. 

I also played around with other ideas, such as making an internal singleton class that is the friend of `BigInt`. The singleton class would be responsible for making `BigInt`'s privates available for the internal functions to use. However, this seems needlessly complicated for a small library. 

## Getters for Internal Functions

However, I eventually gave up and just implemented the getters. Even though implementing getters would also mean that the users would be able to access `BigInt`'s private members as well, the trade-off for cleaner code and easier implementation for internal functions is worth it for me. 

The moral of the story is that although tightening access control is great, overdoing it may be counterproductive. In my case, I spent quite a while trying to figure out a way to not give users read/write access to `BigInt`'s private members before giving up. 

Instead, I could've just written the getters, spent this time writing more code for my algorithms, and leave a note in the documentation warning users that the getters are for internal functions only (something along the lines of "use only if you know what you're doing")